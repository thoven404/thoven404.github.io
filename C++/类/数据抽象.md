# 数据抽象

类的基本思想：**数据抽象** 和 **封装**  

**数据抽象**：一种依赖于 **接口** 和 **实现** 分离的编程以及设计技术  
- **接口**：用户所能执行的操作      
- **实现**：数据成员、接口函数、私有函数  

**封装**：对类的接口和实现的分离

## 定义抽象数据类型
1. **抽象数据类型**：需要封装（隐藏）数据成员，使用户不能直接访问数据成员，而是通过接口使用对象。
- `public` 访问说明符指定类的接口  
- `private` 访问说明符封装了类的实现细节  
    
    封装的优点：（1）确保用户的代码不会无意间破坏封装对象的状态；（2）被封装类的具体实现细节可以随时改变，而无需调整用户级别的代码。
  
2. 成员函数的声明必须在类的内部，定义既可以在类的内部也可以在类的外部。
  
3. 定义在类内部的函数是隐式的 **`inline` 函数**。
  
4. 任何对类成员的直接访问都被看做 `this` 的隐式引用。  
    `this` 是一个常量指针，不允许改变其保存的地址。
  
5. **`cost` 成员函数**：参数列表后加一个 `cost` 关键字，作用是修改隐式 `this` 指针的类型为指向常量的常量指针，使其不能改变对象的数据成员。

6. **默认构造函数** 初始化规则：如果存在类内初始值，就用它来初始化成员，否则就执行默认初始化。
    只有当类没有声明任何构造函数时，编译器才会自动生成默认构造函数。
    如果声明了构造函数，可以使用 `== default` 要求编译器生成默认构造函数，如 `Sales_data() = default;`

7. 构造函数初始值列表
    ```cpp
    Sales_data(const string &s, unsigned n, double p):
                bookNo(s), units_sold(n), revenue(p*n) {}
    ```

8. 除了定义类的对象的初始化，类还需要控制拷贝、赋值和销毁对象时发生的行为。
- 拷贝：初始化变量以及以值的方式传递或者返回一个对象
- 赋值：使用赋值运算符
- 销毁：对象不再存在时  
    
    如果不主动定义这些操作，则编译器会自动合成它们。

## 访问控制与封装
1. 访问说明符：定义在 `public` 说明符后的成员在整个程序内可被访问，`public` 成员定义类的接口；
    定义在 `private` 说明符后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private` 部分封装了类的实现细节。

2. `class` 和 `struct` 的唯一区别：默认访问权限不一样。
    `struct` 的默认访问权限是 `public` 的，而 `class` 的默认访问权限是 `private` 的。

3. 类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**。
    友元声明：在类定义的内部，在函数声明语句之前加上关键字 `friend` 即可。友元不是类的成员，不受它所在区域访问控制级别的约束。

## 类的其他特性
1. 定义在类内部的成员是自动 `inline` 的。最好只在类外部定义的地方说明 `inline`，使类更容易理解。`inline` 成员函数应该与相应的类定义在同一个头文件中。

2. `mutable` 的数据成员即使是在 `const` 成员函数内，或者即使它是 `const` 对象的成员，也可以被改变。

3. 非常量版本的函数对于常量对象是不可用的，只能在一个常量对象上调用 `const` 成员函数。可以在非常量对象上调用常量或者非常量版本的函数。

4.  可以仅声明类而暂时不定义它。这种声明被称为前向声明，在声明之后定义之前它类是一个不完全类型。不完全类型可以在非常有限的情形下使用：定义指向该类型的指针或者引用；声明以该类型为返回类型或者参数的函数。类允许包含指向它自身类型的指针或者引用。

## 构造函数再探
1. 使用初始值列表时，类成员的初始化顺序与他们在类定义中出现的顺序一致。

2. 如果一个构造函数为所有参数都提供了默认实参，则它实际上也定义了默认构造函数。

3. **委托构造函数**使用它所属类的其他构造函数执行它自己的初始化过程，或者说把它的一些职责委托给了其他构造函数。

4. **转换构造函数**：构造函数只接受一个实参，实际上定义了转换为此类类型的隐式转换机制。可以在其声明前面加关键字 `explicit` 阻止隐式转换，此时该构造函数只能以直接初始化的形式使用，不能执行拷贝形式的初始化。

5. **聚合类**：（1）所有成员都是 `public` 的；（2）没有定义任何构造函数；（3）没有类内初始值；（4）没有基类，也没有 `virtual` 函数。我们可以提供一个用花括号括起来的初始化列表初始化聚合类的数据成员。

6. **字面值常量类**；

## 类的静态成员
1. **类的静态成员**：成员与类本身直接相关，而不是与类的各个对象保持关联。

2. 在类的外部定义静态成员时，不能重复 `static` 关键字，`static` 关键字只能出现在类内部的声明语句。

3. 一般来说，不能在类的内部初始化静态数据成员，必须要在类的外部定义和初始化静态成员。最好是把静态数据成员的定义与其他非内联函数的定义放置在同一个文件中。


# 拷贝控制

类的五种特殊的成员函数控制对象的拷贝、移动、赋值和销毁：拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数。

拷贝和移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么  
拷贝和移动赋值函数：定义了将一个对象赋予同类型的另一个对象时做什么  
析构函数：定义了此类型对象销毁时做什么  
以上操作都被称为拷贝控制操作。  
如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

## 拷贝构造函数
如果一个构造函数的第一个参数是自身类类型的引用（几乎总是一个`const`引用），且任何额外参数都有默认值，则此构造函数是拷贝构造函数。

```cpp
class Foo{
public:
    Foo();              // 默认构造函数
    Foo(const Foo&);    // 拷贝构造函数
}
```

1. 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

2. 合成拷贝构造函数会将其参数的非`static`成员逐个拷贝到正在创建的对象中。

3. 当使用直接初始化时，实际上是要求编译器使用普通的函数匹配选择与提供的参数最匹配的构造函数，而当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。
    拷贝初始化通常使用拷贝构造函数来完成，有时也会使用移动构造函数来完成。

4. 拷贝初始化不仅在使用 `=` 定义变量时会发生，在下列情况下也会发生：
    - 将一个对象作为实参传递给一个非引用类型的形参；
    - 从一个返回类型为非引用类型的函数返回一个对象；
    - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

5. 拷贝构造函数参数需要时引用类型的原因：如果参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数。

## 拷贝赋值运算符



