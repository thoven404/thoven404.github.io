---
sort: 2
---

# 类设计者的工具
## 拷贝控制

1. 类的五种特殊的成员函数控制对象的拷贝、移动、赋值和销毁：拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数。
    拷贝和移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么  
    拷贝和移动赋值函数：定义了将一个对象赋予同类型的另一个对象时做什么  
    析构函数：定义了此类型对象销毁时做什么  
    以上操作都被称为拷贝控制操作。  
    如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

2. 如果一个构造函数的第一个参数是自身类类型的引用（几乎总是一个`const`引用），且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。
    ```cpp
    class Foo{
    public:
        Foo();              // 默认构造函数
        Foo(const Foo&);    // 拷贝构造函数
    };
    ```

3. 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

4. **合成拷贝构造函数**会将其参数的非`static`成员逐个拷贝到正在创建的对象中。

5. 当使用直接初始化时，实际上是要求编译器使用普通的函数匹配选择与提供的参数最匹配的构造函数，而当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。
    拷贝初始化通常使用拷贝构造函数来完成，有时也会使用移动构造函数来完成。

6. 拷贝初始化不仅在使用 `=` 定义变量时会发生，在下列情况下也会发生：
    - 将一个对象作为实参传递给一个非引用类型的形参；
    - 从一个返回类型为非引用类型的函数返回一个对象；
    - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

7. 拷贝构造函数参数需要是引用类型的原因：如果参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数。

8. **拷贝赋值运算符**用于控制对象如何赋值。类如果未定义其拷贝赋值运算符，编译器会为它合成一个。

9. 拷贝赋值运算符接受一个与其所在类相同类型的参数，通常返回一个指向其左侧运算对象的引用。
    ```cpp
    class Foo{
    public:
        Foo& operator=(const Foo&); // 拷贝赋值运算符
    };
    ```

10. 标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

11. **析构函数**用于释放对象使用的资源，并销毁对象的非 `static` 数据成员。

12. 析构函数由 `~` 接类名构成，没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载，一个类只有唯一一个析构函数。
    ```cpp
    class Foo{
    public:
        ~Foo(); // 析构函数
    };
    ```

13. 析构函数首先执行函数体，然后按初始化顺序的逆序销毁成员。隐式销毁一个内置指针类型的成员不会 `delete` 它所指向的对象。

14. 无论何时一个对象被销毁，就会自动调用其析构函数：
    - 变量在离开其作用域时被销毁
    - 当一个对象被销毁时，其成员也会被销毁
    - 容器被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用 `delete` 运算符时被销毁
    - 对于临时对象，当创建它的完整表达式结束时被销毁

15. 当一个类未定义其析构函数时，编译器会为其定义一个**合成析构函数**。合成析构函数的函数体一般为空。

16. 三/五法则：当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。
    - 如果这个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。（如需要定义一个析构函数来释放构造函数分配的内存）
    - 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。

17. 我们可以通过将拷贝控制成员定义为 `=default` 来显式地要求编译器生成合成的版本。

18. 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。

19. 在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除函数来阻止拷贝。**删除函数**：虽然声明了，但是不能以任何方式使用。在函数的参数列表后面加上 `=delete` 来指出我们希望将它定义为删除的：
    ```cpp
    struct NoCopy{
        NoCopy() = default; // 合成的默认构造函数
        NoCopy(const NoCopy&) = delete;             // 阻止拷贝
        NoCopy &operator=(const NoCopy&) = delete;  // 阻止赋值
    };
    ```
    与 `=default` 不同，`=delete` 必须出现在函数第一次声明的时候。  
    此外，可以对任何函数指定 `=delete`。当我们希望引导函数匹配过程时，删除函数有时也是有用的。  
    值得注意的是，我们不能删除析构函数。

20. 对某些类来说，编译器将合成拷贝构造函数、合成拷贝运算符、合成默认构造函数定义为删除的函数：
    - 如果类的某个成员的析构函数是删除的或不可访问（例如是 `private` 的），则类的合成析构函数被定义为删除的。
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的；如果类的某个成员的析构函数是删除的或不可访问的，则类的合成的拷贝构造函数也被定义为删除的。
    - 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 `const` 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个 `const` 成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。
    本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。  
    一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。  
    对于具有引用成员或无法默认构造的 `const` 成员的类，编译器不会为其合成默认构造函数；如果一个类有 `const` 成员，则它不能使用合成的拷贝赋值运算符。  
    对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

## 拷贝控制和资源管理
1. 类的行为像一个值：当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。
    类的行为像指针：拷贝一个像指针的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

2. **行为像值**的类示例
    ```cpp
    class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
            ps(new std::string(s)), i(0) {}
        
        // 拷贝构造函数。对ps指向的string，每个 HasPtr 对象都有自己的拷贝
        HasPtr(const HasPtr &p):
            ps(new std::string(*(p.ps))), i(p.i){}

        // 拷贝赋值运算符，注意要防范自赋值操作
        HasPtr &operator=(const HasPtr &rhs){
            std::string *newp = new std::string(*(rhs.ps));
            delete ps;
            ps = newp;
            i = rhs.i;
            return *this;
        }

        // 析构函数，释放指针指向的内存
        ~HasPtr(){
            delete ps;
        }
    
    private:
        std::string *ps;
        int i;
    };
    ```

3. 编写赋值运算符时，有两点需要注意：
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作（一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后销毁左侧运算对象的现有成员就是安全的了，然后再将数据从临时对象拷贝到左侧运算对象的成员中）。
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

4. 定义行为像指针的类，析构函数不能单方面释放的 `string` 内存，只有当最后一个指向 `string` 的 `HasPtr` 销毁时，它才可以释放 `string` 。
    令一个类展现类似指针的行为的最好方法是使用 `shared_ptr` 来管理类中的资源，拷贝（或赋值）一个 `shared_ptr` 会拷贝（赋值） `shared_ptr` 所指向的指针。`shared_ptr` 类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，`shared_ptr` 类负责释放资源。
    如果希望直接管理资源，可以使用 **引用计数**
    引用计数的工作方式如下：
    - 每个构造函数，除了初始化对象外，还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，并且递增共享的计数器。
    - 析构函数递减计数器，如果计数器变为0，则析构函数释放状态。
    - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，就必须销毁状态。
    示例：
    ```cpp
    class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)){}

        // 拷贝构造函数
        HasPtr &HasPtr(const HasPtr& hp):
        ps(hp.ps), i(0), use(hp.use){
            (*use)++;
        }

        // 拷贝赋值运算符
        HasPtr &operator=(const HasPtr& hp){
            
            ++(*hp.use);

            if(--(*use) == 0){
                delete ps;
                delete use;
            }

            ps = hp.ps;
            i = hp.i;
            use = hp.use;   // 引用计数

            return *this;   // 注意要返回本对象
        }

        // 析构函数
        ~HasPtr(){
            if(--*use == 0){
                delete ps;
                delete use;
            }
        }

    private:
        std::string *ps;
        int i;
        std::size_t *use;

    };
    ```

## 交换操作
1. 对于那些与重排元素顺序的算法一起使用的类，定义 `swap` 是非常重要的，这类算法在交换两个元素时会调用 `swap` 。
    如果一个类定义了自己的 `swap` ，那么算法将使用类自定义的版本。否则，算法将使用标准库定义的 `swap` 。

    ```cpp
    class HasPtr{
    public:

    private:

    };
    ```

    使用标准库版本的 `swap` 交换两个对象可能会导致不必要的拷贝（指针指向的内存）。我们可以在我们的类上定义一个自己版本的 `swap` 来重载 `swap` 的默认行为。`swap` 的典型实现如下：

    ```cpp
    class HasPtr{
        // 定义为 friend 使其能访问 HasPtr 的私有数据成员
        friend void swap(HasPtr&, HasPtr&);
    };

    inline
    void swap(HasPtr &lhs, HasPtr &rhs){
        using std::swap;
        // 以下调用的不是 std::swap
        // 调用应该都是未加限定的，即不是 std::swap()。
        swap(lhs.ps, rhs.ps);   // 交换指针，而不是 string 数据
        swap(lhs.i, rhs.i);     // 交换 int 成员
    }
    ```

    如果存在类型特定的 `swap` 版本，`swap` 调用会与之匹配，如果不存在类型特定的版本，则将会使用 `std` 中的版本。

2. 定义 `swap` 的类通常用 `swap` 来定义他们的赋值运算符。这些运算符使用了一种名为拷贝并交换的计数，将左侧运算对象与右侧运算对象的一个副本进行交换：

    ```cpp
    HasPtr& HasPtr::operator=(HasPtr rhs){      // 注意参数不能是引用
        // 交换左侧运算对象和局部变量 rhs 的内容
        swap(*this, rhs);
        return *this;
    }
    ```

    这个计数自动处理了自赋值情况且天然就是异常安全的。通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确。

## 拷贝控制示例

## 动态内存管理类

## 对象移动