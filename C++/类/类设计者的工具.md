---
sort: 2
---

# 类设计者的工具
## 拷贝控制

1. 类的五种特殊的成员函数控制对象的拷贝、移动、赋值和销毁：拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数、析构函数。
    - 拷贝和移动构造函数：定义了当用同类型的另一个对象初始化本对象时做什么  
    - 拷贝和移动赋值函数：定义了将一个对象赋予同类型的另一个对象时做什么  
    - 析构函数：定义了此类型对象销毁时做什么

    以上操作都被称为拷贝控制操作。  
    如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

2. 如果一个构造函数的第一个参数是自身类类型的引用（几乎总是一个`const`引用），且任何额外参数都有默认值，则此构造函数是**拷贝构造函数**。

    ```cpp
    class Foo{
    public:
        Foo();              // 默认构造函数
        Foo(const Foo&);    // 拷贝构造函数
    };
    ```

3. 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。

4. **合成拷贝构造函数**会将其参数的非`static`成员逐个拷贝到正在创建的对象中。

5. 当使用直接初始化时，实际上是要求编译器使用普通的函数匹配选择与提供的参数最匹配的构造函数，而当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。  
    拷贝初始化通常使用拷贝构造函数来完成，有时也会使用移动构造函数来完成。

6. 拷贝初始化不仅在使用 `=` 定义变量时会发生，在下列情况下也会发生：
    - 将一个对象作为实参传递给一个非引用类型的形参；
    - 从一个返回类型为非引用类型的函数返回一个对象；
    - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

7. 拷贝构造函数参数需要是引用类型的原因：如果参数不是引用类型，则调用永远不会成功——为了调用拷贝构造函数，必须拷贝它的实参，但为了拷贝实参，又需要调用拷贝构造函数。

8. **拷贝赋值运算符**用于控制对象如何赋值。类如果未定义其拷贝赋值运算符，编译器会为它合成一个。

9.  拷贝赋值运算符接受一个与其所在类相同类型的参数，通常返回一个指向其左侧运算对象的引用。

    ```cpp
    class Foo{
    public:
        Foo& operator=(const Foo&); // 拷贝赋值运算符
    };
    ```

10. 标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值是左侧运算对象的引用。

11. **析构函数**用于释放对象使用的资源，并销毁对象的非 `static` 数据成员。

12. 析构函数由 `~` 接类名构成，没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载，一个类只有唯一一个析构函数。

    ```cpp
    class Foo{
    public:
        ~Foo(); // 析构函数
    };
    ```

13. 析构函数首先执行函数体，然后按初始化顺序的逆序销毁成员。隐式销毁一个内置指针类型的成员不会 `delete` 它所指向的对象。

14. 无论何时一个对象被销毁，就会自动调用其析构函数：
    - 变量在离开其作用域时被销毁
    - 当一个对象被销毁时，其成员也会被销毁
    - 容器被销毁时，其元素被销毁
    - 对于动态分配的对象，当对指向它的指针应用 `delete` 运算符时被销毁
    - 对于临时对象，当创建它的完整表达式结束时被销毁

15. 当一个类未定义其析构函数时，编译器会为其定义一个**合成析构函数**。合成析构函数的函数体一般为空。

16. 三/五法则：当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个析构函数。
    - 如果这个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝构造函数和拷贝赋值运算符。（如需要定义一个析构函数来释放构造函数分配的内存）
    - 如果一个类需要一个拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。

17. 我们可以通过将拷贝控制成员定义为 `=default` 来显式地要求编译器生成合成的版本。

18. 大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是隐式地还是显式地。

19. 在新标准下，可以通过将拷贝构造函数和拷贝赋值运算符定义为删除函数来阻止拷贝。**删除函数**：虽然声明了，但是不能以任何方式使用。在函数的参数列表后面加上 `=delete` 来指出我们希望将它定义为删除的：

    ```cpp
    struct NoCopy{
        NoCopy() = default; // 合成的默认构造函数
        NoCopy(const NoCopy&) = delete;             // 阻止拷贝
        NoCopy &operator=(const NoCopy&) = delete;  // 阻止赋值
    };
    ```

    与 `=default` 不同，`=delete` 必须出现在函数第一次声明的时候。  
    此外，可以对任何函数指定 `=delete`。当我们希望引导函数匹配过程时，删除函数有时也是有用的。  
    值得注意的是，我们不能删除析构函数。

20. 对某些类来说，编译器将合成拷贝构造函数、合成拷贝运算符、合成默认构造函数定义为删除的函数：
    - 如果类的某个成员的析构函数是删除的或不可访问（例如是 `private` 的），则类的合成析构函数被定义为删除的。
    - 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的；如果类的某个成员的析构函数是删除的或不可访问的，则类的合成的拷贝构造函数也被定义为删除的。
    - 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个 `const` 的或引用成员，则类的合成拷贝赋值运算符被定义为删除的。
    - 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个 `const` 成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

    本质上，这些规则的含义是：如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。  
    一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的。  
    对于具有引用成员或无法默认构造的 `const` 成员的类，编译器不会为其合成默认构造函数；如果一个类有 `const` 成员，则它不能使用合成的拷贝赋值运算符。  
    对于有引用成员的类，合成拷贝赋值运算符被定义为删除的。

## 拷贝控制和资源管理
1. 类的行为像一个值：当我们拷贝一个像值的对象时，副本和原对象是完全独立的。改变副本不会对原对象有任何影响，反之亦然。  
    类的行为像指针：拷贝一个像指针的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。

2. **行为像值**的类示例

    ```cpp
    class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
            ps(new std::string(s)), i(0) {}
        
        // 拷贝构造函数。对ps指向的string，每个 HasPtr 对象都有自己的拷贝
        HasPtr(const HasPtr &p):
            ps(new std::string(*(p.ps))), i(p.i){}

        // 拷贝赋值运算符，注意要防范自赋值操作
        HasPtr &operator=(const HasPtr &rhs){
            std::string *newp = new std::string(*(rhs.ps));
            delete ps;
            ps = newp;
            i = rhs.i;
            return *this;
        }

        // 析构函数，释放指针指向的内存
        ~HasPtr(){
            delete ps;
        }
    
    private:
        std::string *ps;
        int i;
    };
    ```

3. 编写赋值运算符时，有两点需要注意：
    - 如果将一个对象赋予它自身，赋值运算符必须能正确工作（一个好的模式是先将右侧运算对象拷贝到一个局部临时对象中，拷贝完成后销毁左侧运算对象的现有成员就是安全的了，然后再将数据从临时对象拷贝到左侧运算对象的成员中）。
    - 大多数赋值运算符组合了析构函数和拷贝构造函数的工作。

4. 定义行为像指针的类，析构函数不能单方面释放的 `string` 内存，只有当最后一个指向 `string` 的 `HasPtr` 销毁时，它才可以释放 `string` 。  
    令一个类展现类似指针的行为的最好方法是使用 `shared_ptr` 来管理类中的资源，拷贝（或赋值）一个 `shared_ptr` 会拷贝（赋值） `shared_ptr` 所指向的指针。`shared_ptr` 类自己记录有多少用户共享它所指向的对象。当没有用户使用对象时，`shared_ptr` 类负责释放资源。  
    如果希望直接管理资源，可以使用 **引用计数**  
    引用计数的工作方式如下：
    - 每个构造函数，除了初始化对象外，还要创建一个引用计数，用来记录有多少对象与正在创建的对象共享状态。
    - 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器，并且递增共享的计数器。
    - 析构函数递减计数器，如果计数器变为0，则析构函数释放状态。
    - 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，就必须销毁状态。
    
    示例：

    ```cpp
    class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0), use(new std::size_t(1)){}

        // 拷贝构造函数
        HasPtr &HasPtr(const HasPtr& hp):
        ps(hp.ps), i(0), use(hp.use){
            (*use)++;
        }

        // 拷贝赋值运算符
        HasPtr &operator=(const HasPtr& hp){
            
            ++(*hp.use);

            if(--(*use) == 0){
                delete ps;
                delete use;
            }

            ps = hp.ps;
            i = hp.i;
            use = hp.use;   // 引用计数

            return *this;   // 注意要返回本对象
        }

        // 析构函数
        ~HasPtr(){
            if(--*use == 0){
                delete ps;
                delete use;
            }
        }

    private:
        std::string *ps;
        int i;
        std::size_t *use;

    };
    ```

## 交换操作
1. 对于那些与重排元素顺序的算法一起使用的类，定义 `swap` 是非常重要的，这类算法在交换两个元素时会调用 `swap` 。  
    如果一个类定义了自己的 `swap` ，那么算法将使用类自定义的版本。否则，算法将使用标准库定义的 `swap` 。

    ```cpp
    class HasPtr{
    public:

    private:

    };
    ```

    使用标准库版本的 `swap` 交换两个对象可能会导致不必要的拷贝（指针指向的内存）。我们可以在我们的类上定义一个自己版本的 `swap` 来重载 `swap` 的默认行为。`swap` 的典型实现如下：

    ```cpp
    class HasPtr{
        // 定义为 friend 使其能访问 HasPtr 的私有数据成员
        friend void swap(HasPtr&, HasPtr&);
    };

    inline
    void swap(HasPtr &lhs, HasPtr &rhs){
        using std::swap;
        // 以下调用的不是 std::swap
        // 调用应该都是未加限定的，即不是 std::swap()。
        swap(lhs.ps, rhs.ps);   // 交换指针，而不是 string 数据
        swap(lhs.i, rhs.i);     // 交换 int 成员
    }
    ```

    如果存在类型特定的 `swap` 版本，`swap` 调用会与之匹配，如果不存在类型特定的版本，则将会使用 `std` 中的版本。

2. 定义 `swap` 的类通常用 `swap` 来定义他们的赋值运算符。这些运算符使用了一种名为拷贝并交换的计数，将左侧运算对象与右侧运算对象的一个副本进行交换：

    ```cpp
    HasPtr& HasPtr::operator=(HasPtr rhs){      // 注意参数不能是引用
        // 交换左侧运算对象和局部变量 rhs 的内容
        swap(*this, rhs);
        return *this;
    }
    ```

    这个计数自动处理了自赋值情况且天然就是异常安全的。通过在改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确。

## 对象移动
1. 新标准的一个最主要的特性是可以移动而非拷贝对象的能力。在某些情况下，对象拷贝后就立即被销毁了，那么移动而非拷贝对象会大幅度提升性能。

2. 标准库容器、`string` 和 `shared_ptr` 类既支持移动也支持拷贝。IO类和 `unique_ptr` 类可以移动但不能拷贝。

3. 为了支持移动操作，新标准引入了一种新的引用类型——**右值引用**，就是必须绑定到右值的引用。  
    通过 `&&` 来获得右值引用。  
    右值引用有一个重要的性质——只能绑定到一个将要销毁的对象。

4. 左值和右值是表达式的属性，一些表达式生成或要求左值，而另外一些则生成或要求右值。一般而言，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。  
    一个右值引用也不过是某个对象的另一个名字而已。对于常规引用（为了与右值引用区分开来，我们可以称之为左值引用），我们不能将其绑定到要求转换的表达式、字面常量、或是返回右值的表达式。右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用直接绑定到一个左值上：

    ```cpp
    int i = 42;
    int &r = i;             // 正确：r引用i
    int &&rr = i;           // 错误：不能将一个右值引用绑定到一个左值上
    int &r2 = i * 42;       // 错误：i * 42 是一个右值
    const int &r3 = i * 42; // 正确：可以将一个 const 的引用绑定到一个右值上
    int &&rr2 = i * 42;     // 正确：将 rr2 绑定到乘法结果上
    ```

5. 左值有持久的状态，而右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。  
    由于右值引用只能绑定到临时对象，我们得知：
    - 所引用的对象将要被销毁
    - 该对象没有其他用户

    这两个特性意味着使用右值引用的代码可以自由地接管所引用的对象的资源。

6. 变量可以看做只有一个运算对象而没有运算符的表达式，变量表达式都是左值。带来的结果就是，我们不能将一个右值引用绑定到一个右值引用类型的变量上：

    ```cpp
    int &&rr1 = 42;     // 正确：字面值常量是右值
    int &rr2 = rr1;     // 错误：表达式rr1是左值
    ```

7. 可以通过调用一个名为 `move` 的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 `utility` 中。

    ```cpp
    int &&rr3 = std::move(rr1);     // 正确
    ```

    `move` 告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。  
    调用 `move` 就意味着承诺：除了对 `rr1` 赋值或销毁它外，我们将不再使用它。在调用 `move` 后，我们不能对移后源对象的值做任何假设。  
    与大多数标准库名字的使用不同，对 `move` 我们不提供 `using` 声明，我们直接调用 `std::move` 而不是 `move` 。  

8. 为了让我们自己的类型支持移动操作，需要为其定义**移动构造函数**和**移动赋值运算符**。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源。  
    类似拷贝构造函数，移动构造函数的第一个参数是该类类型的一个引用，任何额外的参数都必须有默认实参。不同于拷贝构造函数的是，这个引用参数在移动构造函数中是一个右值引用。  
    除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象。  
    例子：实现从一个 `StrVec` 到另一个 `StrVec` 的元素的移动而非拷贝：  

    ```cpp
    StrVec::StrVec(StrVec &&s) noexcept     // 移动操作不应抛出任何异常
    // 成员初始化器接管 s 中的资源
    : elements(s.elements), first_free(s.first_free), cap(s.cap)
    {
        // 令 s 进入这样的状态——对其运行析构函数是安全的
        s.elements = s.first_free = s.cap = nullptr;    // 该对象只有3个 string 指针
    }
    ```

    移动构造函数不分配任何新内存，它接管给定的右值引用的内存。最终，移后源对象会被销毁，意味着将在其上运行析构函数。

9. 由于移动操作“窃取”资源，它通常不分配任何资源，因此移动操作通常不会抛出任何异常。除非标准库知道我们的移动构造函数不会抛出异常，否则它会认为移动我们的类对象时可能会抛出异常，并且为了处理这种可能性而做一些额外的工作。  
    一种通知标准库的方法是在构造函数中指明 `noexcept` 。必须在类头文件的声明和定义中都指定 `noexcept` 。

10. 标准库容器能对异常发生时其自身的行为提供保障，例如 `vector` 保证，调用 `push_back` 时发生异常， `vector` 自身不会发生改变。  
    如果希望在 `vector` 重新分配内存这类情况下对我们自定义类型的对象进行移动而不是拷贝，就必须显式地告诉标准库我们的移动构造函数可以安全使用。  

11. 类似拷贝赋值运算符，移动赋值运算符必须正确处理自赋值：

    ```cpp
    StrVec &StrVec::operator=(StrVec &&rhs) noexcept
    {
        if(this != &rhs){
            free();                     // 释放已有元素
            elements = rhs.elements;    // 从 rhs 接管资源
            first_free = rhs.first_free;
            cap = rhs.cap;
            // 将rhs置于可析构状态
            rhs.elements = rhs.first_free = rhs.cap = nullptr;
        }

        return *this;
    }
    ```

    与其他任何赋值运算符一样，关键点是我们不能在使用右侧运算对象的资源之前就释放左侧运算对象的资源（可能是相同的资源）。

12. 只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个非 `static` 数据成员都可以移动时，编译器才会给它合成移动构造函数或移动赋值运算符。

13. 一般情况下，拷贝构造函数满足对应的移动构造函数的要求。

14. 新标准库定义了一种移动迭代器适配器，通过改变给定迭代器的解引用运算符的行为来适配此迭代器。  
    一般来说，一个迭代器的解引用运算符返回一个指向元素的左值，而移动迭代器的解引用运算符生成一个右值引用。

15. 建议不要随意使用移动操作。  
    由于一个移后源对象具有不确定的状态，对其调用 `std::move` 是危险的。当我们调用 `move` 时，必须绝对确认移后源对象没有其他用户。

16. 在参数列表后放置一个**引用限定符**，可以指出 `this` 的左值/右值属性。







