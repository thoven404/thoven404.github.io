---
sort: 3
---

# 面向对象程序设计

1. 面向对象程序设计（OOP）的核心思想是数据抽象、继承和动态绑定。
    - 使用数据抽象，可以将类的接口和实现分离；
    - 使用继承，可以定义相似的类型并对其相似关系建模；
    - 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

2. 通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，每个派生类定义各自特有的成员。

3. 对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。

    ```cpp
    class Quote{
    public:
        std::string isbn() const;
        virtual double net_price(std::size_t n) const;    
    };
    ```

    派生类通过类派生列表指出它是从哪个基类继承而来的

    ```cpp
    class Bulk_quote: public Quote{
    public:
        double ner_price(std::size_t) const override;
    };
    ```

    因为 Bulk_quote 派生列表中使用了 public 关键字，因此我们完全可以把 Bulk_quote 的对象当成 Quote 的对象来使用。

    派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以选择是否在这样的函数之前加上 virtual 关键字。新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，方法是在函数的形参列表后增加 override 关键字。

4. 当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

5. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

6. 派生类可以继承其基类的成员，当遇到虚函数时，需要对其重新定义。

7. 任何构造函数之外的非静态函数都可以是虚函数。关键字 virtual 只能出现在类内部的声明预计之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。

8. 派生类可以访问基类的公有成员，而不能访问私有成员。派生类可以访问基类的 protected 成员，而其他用户不能访问。

9. 如果一个派生是 public 的，则基类的公有成员也是派生类接口的组成部分。此外我们能将公有派生对象绑定到基类的引用或指针上。

10. 大多数类都只继承自一个类，称为 单继承。

11. 如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似其他的普通成员，派生类会直接继承其在基类中的版本。

12. 
