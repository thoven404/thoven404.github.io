---
sort: 3
---

# 面向对象程序设计

## OOP：概述
1. 面向对象程序设计（OOP）的核心思想是数据抽象、继承和动态绑定。
    - 使用数据抽象，可以将类的接口和实现分离；
    - 使用继承，可以定义相似的类型并对其相似关系建模；
    - 使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。

2. 通过继承联系在一起的类构成一种层次关系。通常在层次关系的根部有一个基类，继承得到的类称为派生类。基类负责定义在层次关系中所有类共同拥有的成员，每个派生类定义各自特有的成员。

3. 对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明成虚函数。

    ```cpp
    class Quote{
    public:
        std::string isbn() const;
        virtual double net_price(std::size_t n) const;    
    };
    ```

    派生类通过类派生列表指出它是从哪个基类继承而来的

    ```cpp
    class Bulk_quote: public Quote{
    public:
        double ner_price(std::size_t) const override;
    };
    ```

    因为 Bulk_quote 派生列表中使用了 public 关键字，因此我们完全可以把 Bulk_quote 的对象当成 Quote 的对象来使用。

    派生类必须在其内部对所有重新定义的虚函数进行声明。派生类可以选择是否在这样的函数之前加上 virtual 关键字。新标准允许派生类显式地注明它将使用哪个成员函数改写基类的虚函数，方法是在函数的形参列表后增加 override 关键字。

## 定义基类和派生类

1. 当使用基类的引用（或指针）调用一个虚函数时将发生动态绑定。根据引用或指针所绑定的对象类型的不同，该调用可能执行基类的版本，也可能执行某个派生类的版本。

2. 基类通常都应该定义一个虚析构函数，即使该函数不执行任何实际操作。

3. 派生类可以继承其基类的成员，当遇到虚函数时，需要对其重新定义。

4. 任何构造函数之外的非静态函数都可以是虚函数。关键字 virtual 只能出现在类内部的声明预计之前而不能用于类外部的函数定义。如果基类把一个函数声明为虚函数，则该函数在派生类中隐式地也是虚函数。

5. 派生类可以访问基类的公有成员，而不能访问私有成员。派生类可以访问基类的 protected 成员，而其他用户不能访问。

6. 如果一个派生是 public 的，则基类的公有成员也是派生类接口的组成部分。此外我们能将公有派生对象绑定到基类的引用或指针上。

7.  大多数类都只继承自一个类，称为 单继承。

8.  如果派生类没有覆盖其基类中的某个虚函数，则该虚函数的行为类似其他的普通成员，派生类会直接继承其在基类中的版本。

9.  因为在派生类对象中含有与其基类对应的组成部分，因此我们可以把派生类的对象当成基类的对象来使用，而且我们也能将基类的指针或引用绑定到派生类对象的基类部分上。这种转换通常称为派生类到基类的类型转换。编译器会隐式地执行派生类到基类的转换。

    ```cpp
    Quote item;
    Bulk_quote bulk;
    Quote *p = &item;
    p = &bulk;          // p 指向 bulk 的 Quote 部分
    Quote &r = bulk;    // r 绑定到 bulk 的 Quote 部分
    ```

10. 派生类必须使用基类的构造函数来初始化它的基类部分。
    ```cpp
    Bulk_quote(const std::string &book, double p, std::size_t qty, double disc):
        Quote(book, p), min_qty(qty), discount(disc){}
    ```

11. 如果基类定义了一个静态成员，则在整个继承体系里只存在该成员的唯一定义。

12. 派生类的声明包含类型，但是不包含它的派生列表。

    ```cpp
    class Bulk_quote : public Quote;    // 错误
    class Bulk_quote;                   // 正确
    ```

13. C++ 11 新标准提供了一种防止继承发生的方法，即在类名后跟一个关键字 `final`。

    ```cpp
    class NoDerived final {/**/};
    ```

14. 不存在从基类向派生类的自动类型转换。

15. 派生类向基类的自动类型转换只对指针或者引用类型有效，在派生类类型和基类类型之间不存在这样的转换。

## 虚函数
1. 当使用基类的引用或指针调用一个虚成员函数时会执行动态绑定。

2. 虚函数必须都有定义，不管它是否被用到。

3. 如果使用 `override` 标记了某个函数，但该函数并没有覆盖已存在的虚函数，编译器将报错。
   
4. 如果把函数定义成 `final` 了，则之后任何尝试覆盖该函数的操作都会引发错误。

5. 使用作用域运算符，可以不对虚函数进行动态绑定，强迫其执行虚函数的某个特定版本。

    ```cpp
    // 强制调用积累中定义的函数而不管 baseP 的动态类型到底是什么
    double undiscounted = baseP->Quote::net_price(42);
    ```

    使用情况：派生类的虚函数调用它覆盖的基类的虚函数版本时。不使用作用域运算符将导致递归。

## 抽象基类
1. 通过在声明语句的分号之前加上 `= 0` 就可以将一个虚函数说明为纯虚函数。`= 0` 只能出现在类内部的虚函数声明语句处。
   
    ```cpp
    class Disc_quote: public Quote{
    public:
        Disc_quote() = dafault;
        double net_price(std::size_t) const = 0;
    };
    ```

2. 和普通的虚函数不一样，一个纯虚函数无须定义。

3. 我们也可以为纯虚函数提供定义，不过函数体必须定义在类的外部。

4. 含有纯虚函数的类是抽象基类，负责定义接口，后续的其他类可以覆盖该接口。

5. 不能创建一个抽象基类的对象。

## 访问控制与继承
1. `protected` 成员对于类的用户来说是不可访问的，对派生类的成员和友元来说是可访问的。

2. 派生类的成员或友元只能通过派生类对象来访问基类的受保护成员。

3. 派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。

4. 派生访问说明符的目的是控制派生类用户对于基类成员的访问权限。
    假定D继承自B：
    - 只有当 D 公有地继承 B 时，用户代码才能使用派生类向基类的转换。
    - 不论 D 以什么方式继承 B，D 的成员函数和友元都能使用派生类向基类的转换；派生类向其直接基类的类型转换对于派生类的成员和友元来说永远是可访问的。
    - 如果 D 继承 B 的方式是 `private` 的，则 D 的派生类的成员和友元不能使用 D 向 B 的类型转换。

5. 友元关系不能继承，基类的友元在访问派生类成员时不具有特殊性，反之亦然。

6. 默认情况下，使用 `class` 关键字定义的派生类是 `private` 继承的，而使用 `struct` 关键字定义的派生类是 `public` 继承的。

7. `struct` 和 `class` 关键字的唯一差别就是 默认成员访问说明符 和 默认派生访问说明符。

## 继承中的类作用域
1. 当存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类作用域无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。

2. 和其他作用域一样，派生类也能重用定义在其直接基类或间接基类中的名字。派生类成员将隐藏同名的基类成员。

3. 可以通过作用域运算符来使用一个被隐藏的基类成员：
   
    ```cpp
    struct Derived: Base{
        int get_base_mem(){ return Base::mem}
    };
    ```
    
    作用域运算符将覆盖掉原有的查找规则，并指示编译器从 Base 类的作用域开始查找 mem。

4. 定义派生类中的函数不会重载其基类中的成员，即使派生类成员和基类成员的形参列表不一致。

## 构造函数与拷贝控制
1. 基类通常应该定义一个虚析构函数，这样我们就能动态分配继承体系中的对象了。通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。

2. 基类默认构造函数初始化派生类对象的基类部分。如果向拷贝（或移动）基类部分，必须在派生类构造函数初始值列表中显式地使用基类的拷贝（或移动）构造函数。

3. 继承的构造函数
   
    ```cpp
    class Bulk_quote: public Disc_quote{
    public:
        using Disc_quote::Disc_quote;   // 继承Disc_quote的构造函数
        double net_price(std::size_t) const;
    }
    ```

    对于基类中的每个构造函数，编译器都在派生类中生成一个形参列表完全相同的构造函数：

    ```cpp
    Bulk_quote(const string &book, double price, size_t qty, double disc):
        Disc_quote(book, price, qty, disc){}
    ```

    如果派生类含有自己的数据成员，则这些成员将被默认初始化。

4. 当基类构造函数含有默认实参时，这些实参并不会被继承。相反，派生类将获得多个继承的构造函数，其中每个构造函数分别省略掉一个含有默认实参的形参。


## 容器与继承
1. 当派生类对象被赋值给基类对象时， 其中的派生类部分将被忽略掉。

2. 当希望在容器中存放具有继承关系的对象时，应该存放基类的指针（或者智能指针）。这些指针所指对象的动态类型可能是基类类型，也可能是派生类类型。
